<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTB Race Results Extractor</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 32px;
            margin-bottom: 8px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 16px;
        }
        
        .content {
            padding: 30px;
        }
        
        .upload-section {
            border: 3px dashed #667eea;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #f8f9ff;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 30px;
        }
        
        .upload-section:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }
        
        .upload-section.dragover {
            background: #e8ebff;
            border-color: #764ba2;
        }
        
        .upload-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
        
        .file-input {
            display: none;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-success {
            background: #10b981;
            color: white;
        }
        
        .btn-success:hover {
            background: #059669;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }
        
        .status-message {
            padding: 16px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .status-info {
            background: #dbeafe;
            color: #1e40af;
            border-left: 4px solid #3b82f6;
        }
        
        .status-success {
            background: #d1fae5;
            color: #065f46;
            border-left: 4px solid #10b981;
        }
        
        .status-error {
            background: #fee2e2;
            color: #991b1b;
            border-left: 4px solid #ef4444;
        }
        
        .preview-section {
            margin-top: 30px;
        }
        
        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .preview-header h2 {
            font-size: 24px;
            color: #1f2937;
        }
        
        .table-container {
            overflow-x: auto;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        th {
            background: #f9fafb;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #374151;
            border-bottom: 2px solid #e5e7eb;
            position: sticky;
            top: 0;
        }
        
        td {
            padding: 12px;
            border-bottom: 1px solid #e5e7eb;
        }
        
        tr:hover {
            background: #f9fafb;
        }
        
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            gap: 12px;
        }
        
        .spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        
        .spinner-small {
            border: 2px solid #f3f4f6;
            border-top: 2px solid #ffffff;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .action-buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: #f9fafb;
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .stat-label {
            font-size: 14px;
            color: #6b7280;
            margin-bottom: 4px;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #1f2937;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        function RaceResultsExtractor() {
            const [file, setFile] = useState(null);
            const [previewData, setPreviewData] = useState(null);
            const [fullData, setFullData] = useState(null);
            const [loading, setLoading] = useState(false);
            const [processing, setProcessing] = useState(false);
            const [status, setStatus] = useState(null);
            const [dragOver, setDragOver] = useState(false);
            const fileInputRef = useRef(null);

            // Initialize PDF.js
            useEffect(() => {
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }, []);

            const handleFileSelect = (selectedFile) => {
                if (selectedFile && selectedFile.type === 'application/pdf') {
                    setFile(selectedFile);
                    setPreviewData(null);
                    setFullData(null);
                    setStatus({ type: 'info', message: `File selected: ${selectedFile.name}` });
                    extractPreview(selectedFile);
                } else {
                    setStatus({ type: 'error', message: 'Please select a valid PDF file' });
                }
            };

            const handleDrop = (e) => {
                e.preventDefault();
                setDragOver(false);
                const droppedFile = e.dataTransfer.files[0];
                handleFileSelect(droppedFile);
            };

            const extractPreview = async (pdfFile) => {
                setLoading(true);
                try {
                    const arrayBuffer = await pdfFile.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    const page = await pdf.getPage(1);
                    const textContent = await page.getTextContent();
                    
                    // Build text with line breaks based on Y position
                    let text = '';
                    let lastY = null;
                    
                    textContent.items.forEach(item => {
                        const currentY = item.transform[5];
                        
                        // Add newline if Y position changed (new line)
                        if (lastY !== null && Math.abs(currentY - lastY) > 5) {
                            text += '\n';
                        }
                        
                        text += item.str + ' ';
                        lastY = currentY;
                    });
                    
                    console.log('Extracted text preview:', text.substring(0, 500));
                    
                    // Parse the first page
                    const results = parseRaceResults(text, true, pdfFile.name);
                    
                    console.log('Parsed results:', results.length, 'entries');
                    
                    if (!results || results.length === 0) {
                        setStatus({ type: 'error', message: 'No race results found in PDF. Please check the file format.' });
                        setPreviewData(null);
                        return;
                    }
                    
                    setPreviewData(results);
                    setStatus({ type: 'success', message: `Preview loaded: ${results.length} entries found on first page` });
                } catch (error) {
                    console.error('Error details:', error);
                    setStatus({ type: 'error', message: `Error extracting preview: ${error.message}` });
                } finally {
                    setLoading(false);
                }
            };

            const processFullDocument = async () => {
                if (!file) return;
                
                setProcessing(true);
                setStatus({ type: 'info', message: 'Processing full document... This may take a moment.' });
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    
                    let allText = '';
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        
                        // Build text with line breaks based on Y position
                        let pageText = '';
                        let lastY = null;
                        
                        textContent.items.forEach(item => {
                            const currentY = item.transform[5];
                            
                            // Add newline if Y position changed (new line)
                            if (lastY !== null && Math.abs(currentY - lastY) > 5) {
                                pageText += '\n';
                            }
                            
                            pageText += item.str + ' ';
                            lastY = currentY;
                        });
                        
                        allText += pageText + '\n\n';
                    }
                    
                    console.log('Full text sample:', allText.substring(0, 500));
                    
                    const results = parseRaceResults(allText, false, file.name);
                    
                    console.log('Full parsing results:', results.length, 'entries');
                    
                    if (!results || results.length === 0) {
                        setStatus({ type: 'error', message: 'No race results found in full document. Please check the file format.' });
                        setFullData(null);
                        return;
                    }
                    
                    setFullData(results);
                    setStatus({ 
                        type: 'success', 
                        message: `Processing complete! ${results.length} total entries extracted from ${pdf.numPages} pages.` 
                    });
                } catch (error) {
                    console.error('Error details:', error);
                    setStatus({ type: 'error', message: `Error processing document: ${error.message}` });
                } finally {
                    setProcessing(false);
                }
            };

            const parseRaceResults = (text, firstPageOnly, filename = '') => {
                const results = [];
                
                // Time conversion functions for LAP4 calculation
                const timeToSeconds = (timeStr) => {
                    if (!timeStr || timeStr === '-' || timeStr === '') return null;
                    // Handle formats: MM:SS.FF, M:SS.FF, HH:MM:SS.FF, H:MM:SS.FF
                    const parts = timeStr.split(':');
                    if (parts.length === 2) {
                        // MM:SS.FF or M:SS.FF
                        const mins = parseInt(parts[0]);
                        const secs = parseFloat(parts[1]);
                        return mins * 60 + secs;
                    } else if (parts.length === 3) {
                        // HH:MM:SS.FF or H:MM:SS.FF
                        const hrs = parseInt(parts[0]);
                        const mins = parseInt(parts[1]);
                        const secs = parseFloat(parts[2]);
                        return hrs * 3600 + mins * 60 + secs;
                    }
                    return null;
                };
                
                const secondsToTime = (totalSecs) => {
                    if (totalSecs === null || totalSecs < 0) return '';
                    const mins = Math.floor(totalSecs / 60);
                    const secs = (totalSecs % 60).toFixed(2);
                    return `${mins}:${secs.padStart(5, '0')}`;
                };
                
                // Extract header info
                const headerMatch = text.match(/UTAH HS MTB (\d+)\s*-\s*REGION (\d+)\s*-\s*(\w+)/);
                const year = headerMatch ? headerMatch[1] : '';
                const region = headerMatch ? headerMatch[2] : '';
                const locationRaw = headerMatch ? headerMatch[3] : '';
                
                // Title case the location for Race Course
                const raceCourse = locationRaw.charAt(0).toUpperCase() + locationRaw.slice(1).toLowerCase();
                
                // Extract race number from filename (e.g., "Race1" or "Race_1" from filename)
                const raceNumMatch = filename.match(/Race[_\s]?(\d+)/i);
                const raceNum = raceNumMatch ? raceNumMatch[1] : '';
                
                // Build Race Name: "Region X: Race Y - Location"
                const raceName = raceNum ? `Region ${region}: Race ${raceNum} - ${raceCourse}` : `Region ${region}: ${raceCourse}`;
                
                // Split into lines
                const lines = text.split(/\n/);
                let currentCategory = '';
                
                // Match category headers
                const categoryPattern = /^((?:Sr\.|Freshman|JV|Sophomore|Varsity|Beginner|Intermediate|Advanced|SLR).*(?:Boys|Girls|7th Grade|8th Grade))$/i;
                
                // Helper function to convert HH:MM:SS.FF to MM:SS.FF
                const convertTime = (timeStr) => {
                    if (!timeStr || timeStr === '-') return '';
                    
                    // Check for invalid time formats (e.g., x:xx:xx)
                    // Valid times should only contain digits, colons, and periods
                    if (!/^[\d:\.]+$/.test(timeStr)) {
                        // Return as-is if it contains invalid characters
                        return timeStr;
                    }
                    
                    const parts = timeStr.split(':');
                    if (parts.length === 3) {
                        // HH:MM:SS.FF format
                        const hours = parseInt(parts[0]);
                        const minutes = parseInt(parts[1]);
                        const seconds = parts[2];
                        
                        // Check if parsing resulted in valid numbers
                        if (isNaN(hours) || isNaN(minutes)) {
                            return timeStr; // Return original if invalid
                        }
                        
                        const totalMinutes = hours * 60 + minutes;
                        return `${totalMinutes}:${seconds}`;
                    }
                    // Already in MM:SS.FF or M:SS format
                    return timeStr;
                };
                
                // Helper function to check if word is all uppercase (for name/team splitting)
                const isAllCaps = (word) => {
                    const letters = word.replace(/[^A-Za-z]/g, '');
                    return letters.length > 0 && letters === letters.toUpperCase();
                };
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    
                    // Skip header row
                    if (line.includes('PLC NO NAME TEAM') || line.includes('UTAH HS MTB') || 
                        line.includes('Individual Results') || !line) {
                        continue;
                    }
                    
                    // Check for category header
                    const catMatch = line.match(categoryPattern);
                    if (catMatch) {
                        currentCategory = catMatch[1].trim();
                        console.log('Found category:', currentCategory);
                        continue;
                    }
                    
                    // Parse data row
                    // Normalize parentheses: ensure spaces around them for consistent splitting
                    let normalizedLine = line.replace(/\(/g, ' (').replace(/\)/g, ') ').replace(/\s+/g, ' ').trim();
                    const parts = normalizedLine.split(/\s+/);
                    
                    // First part should be a number or * (for DNF/DNS)
                    if (parts.length >= 8 && (parts[0].match(/^\d+$/) || parts[0] === '*')) {
                        
                        // FIX #2: Special handling for DNF and DNS entries
                        const lastPart = parts[parts.length - 1];
                        if (lastPart === 'DNF' || lastPart === 'DNS') {
                            const placement = parts[0];
                            const plateNum = parts[1];
                            
                            // Find first dash or DNF/DNS (where laps/status section starts)
                            let firstDashIdx = -1;
                            for (let j = 2; j < parts.length; j++) {
                                if (parts[j] === '-' || parts[j] === 'DNF' || parts[j] === 'DNS') {
                                    firstDashIdx = j;
                                    break;
                                }
                            }
                            
                            // Everything between plate# and first dash is name + team (possibly + points + lap time)
                            let middleParts = [];
                            if (firstDashIdx > 2) {
                                middleParts = parts.slice(2, firstDashIdx);
                            }
                            
                            // FIX: Extract points and lap times from middleParts
                            // Order can vary: sometimes points-then-lap, sometimes just points, sometimes just lap
                            // Example: CREW SMITH Pleasant Grove Biking Vikings 200 21:55 - - - DNF
                            // Example: OWEN NIELSEN Northridge 0 78:52 - - - DNS
                            let points = '';
                            let lap1Time = '';
                            let teamEndIdx = middleParts.length;
                            
                            // First, remove any trailing lap times (format: MM:SS or HH:MM:SS)
                            while (teamEndIdx > 0 && middleParts[teamEndIdx - 1].match(/^\d+:\d+/)) {
                                // Capture the first lap time we find (for DNS with partial completion)
                                if (!lap1Time) {
                                    lap1Time = convertTime(middleParts[teamEndIdx - 1]);
                                }
                                teamEndIdx--;
                            }
                            
                            // Then check if what remains ends with a number (points - can be 1-3 digits)
                            if (teamEndIdx > 0 && middleParts[teamEndIdx - 1].match(/^\d{1,3}$/)) {
                                points = middleParts[teamEndIdx - 1];
                                teamEndIdx--;
                            }
                            
                            // Extract name and team (excluding points and lap times)
                            const nameTeamParts = middleParts.slice(0, teamEndIdx);
                            
                            // Case-based name/team split (same as regular entries)
                            let teamStartIdx = -1;
                            
                            // Find first word that's NOT all caps
                            for (let i = 0; i < nameTeamParts.length; i++) {
                                if (!isAllCaps(nameTeamParts[i])) {
                                    teamStartIdx = i;
                                    break;
                                }
                            }
                            
                            // Fallback: if everything is caps, use position 2
                            if (teamStartIdx === -1) {
                                teamStartIdx = 2;
                            }
                            
                            // Ensure at least 1 word for name
                            if (teamStartIdx < 1) {
                                teamStartIdx = 1;
                            }
                            
                            // Ensure we don't go beyond array bounds
                            if (teamStartIdx >= nameTeamParts.length) {
                                teamStartIdx = nameTeamParts.length - 1;
                            }
                            
                            const name = nameTeamParts.slice(0, teamStartIdx).join(' ');
                            const team = cleanTeamName(nameTeamParts.slice(teamStartIdx).join(' '));
                            
                            const result = {
                                Year: year,
                                Region: region,
                                'Race Name': raceName,
                                'Race Course': raceCourse,
                                'Race Category': currentCategory,
                                Placement: placement,
                                'Plate#': plateNum,
                                Name: name,
                                Team: team,
                                Points: points,
                                LAP1: lap1Time,
                                LAP2: '',
                                LAP3: '',
                                LAP4: '',
                                Penalty: '',
                                'Total Time': lastPart,  // DNF or DNS
                                ValidationError: ''  // No validation for DNF/DNS
                            };
                            
                            results.push(result);
                            console.log(`Parsed ${lastPart}: ${placement} ${plateNum} "${name}" "${team}" Points:${points || 'blank'} LAP1:${lap1Time || 'blank'}`);
                            
                            if (firstPageOnly && results.length >= 20) {
                                break;
                            }
                            continue;  // Skip the rest of the parsing logic
                        }
                        
                        const placement = parts[0];
                        const plateNum = parts[1];
                        
                        // FIX #3: Find first time, 3-digit number, dash, or "DNF" after NO
                        let ptsIdx = -1;
                        let teamEndIdx = -1;
                        
                        for (let j = 2; j < parts.length; j++) {
                            // Check for 3-digit number followed by time or dash
                            if (parts[j].match(/^\d{3}$/) && j + 1 < parts.length && 
                                (parts[j + 1].match(/^\d+:\d+/) || parts[j + 1] === '-')) {
                                ptsIdx = j;
                                teamEndIdx = j - 1;
                                break;
                            }
                            // Check for FIRST dash or time (improved logic)
                            if (parts[j] === '-' || (parts[j].match(/^\d+:\d+/) && 
                                (!parts[j - 1] || !parts[j - 1].match(/^\d{3}$/)))) {
                                ptsIdx = j;
                                teamEndIdx = j - 1;
                                break;
                            }
                            // Check for DNF/DNS (should have been caught by special handler above)
                            if (parts[j] === 'DNF' || parts[j] === 'DNS') {
                                ptsIdx = j;
                                teamEndIdx = j - 1;
                                break;
                            }
                        }
                        
                        if (ptsIdx === -1 || teamEndIdx < 2) continue;
                        
                        // Build the middle section (between NO and PTS/LAP1)
                        const middleParts = parts.slice(2, teamEndIdx + 1);
                        
                        // Case-based name/team split:
                        // Names are ALL CAPS in PDFs, teams are Title Case
                        // Find the first word with lowercase letters (mixed case) = team starts there
                        
                        let teamStartIdx = -1;
                        
                        // Find first word that's NOT all caps (has lowercase = Title Case)
                        for (let i = 0; i < middleParts.length; i++) {
                            if (!isAllCaps(middleParts[i])) {
                                teamStartIdx = i;
                                break;
                            }
                        }
                        
                        // Fallback: if everything is caps (shouldn't happen), use position 2
                        if (teamStartIdx === -1) {
                            teamStartIdx = 2;
                        }
                        
                        // Ensure at least 1 word for name
                        if (teamStartIdx < 1) {
                            teamStartIdx = 1;
                        }
                        
                        // Ensure we don't go beyond array bounds
                        if (teamStartIdx >= middleParts.length) {
                            teamStartIdx = middleParts.length - 1;
                        }
                        
                        // Extract name (everything before team) and team (everything from team start onward)
                        const name = middleParts.slice(0, teamStartIdx).join(' ');
                        const team = cleanTeamName(middleParts.slice(teamStartIdx).join(' '));
                        
                        // Check if PTS exists or is blank
                        let actualPtsIdx = -1;
                        let actualLap1Idx = ptsIdx;
                        
                        if (parts[ptsIdx].match(/^\d{3}$/)) {
                            // It's a 3-digit number, so this is PTS
                            actualPtsIdx = ptsIdx;
                            actualLap1Idx = ptsIdx + 1;
                        } else {
                            // It's a time, so PTS is blank and this is LAP1
                            actualPtsIdx = -1;
                            actualLap1Idx = ptsIdx;
                        }
                        
                        // Extract values working from the END backwards
                        const totalTime = parts[parts.length - 1]; // Last element is always total time
                        
                        // Extract points
                        const points = actualPtsIdx >= 0 ? parts[actualPtsIdx] : '';
                        
                        // Extract all candidate time values between actualLap1Idx and totalTime
                        const allCandidates = [];
                        for (let i = actualLap1Idx; i < parts.length - 1; i++) {
                            allCandidates.push(parts[i] || '');
                        }
                        
                        // Penalty detection logic (max 4 laps in Utah HS MTB)
                        // Rule 1: If dash followed by time value, that time is penalty
                        // Rule 2: If 5+ time values, last one is penalty
                        let penalty = '';
                        let lapValues = [];
                        
                        // Check for dash followed by time (dash indicates empty LAP slot, next value is penalty)
                        let dashIdx = -1;
                        for (let i = 0; i < allCandidates.length - 1; i++) {
                            if (allCandidates[i] === '-' && 
                                allCandidates[i + 1] && 
                                allCandidates[i + 1].match(/^\d+:\d+/)) {
                                dashIdx = i;
                                break;
                            }
                        }
                        
                        if (dashIdx >= 0) {
                            // Dash found - everything after dash is penalty
                            lapValues = allCandidates.slice(0, dashIdx + 1); // Include the dash
                            penalty = allCandidates[dashIdx + 1];
                        } else {
                            // No dash pattern - count time values
                            const timeValues = allCandidates.filter(c => c && c !== '-' && c.match(/^\d+:\d+/));
                            
                            if (timeValues.length > 4) {
                                // More than 4 time values - last one is penalty
                                // Find the last time value position in allCandidates
                                let lastTimeIdx = -1;
                                for (let i = allCandidates.length - 1; i >= 0; i--) {
                                    if (allCandidates[i] && allCandidates[i] !== '-' && allCandidates[i].match(/^\d+:\d+/)) {
                                        lastTimeIdx = i;
                                        break;
                                    }
                                }
                                
                                if (lastTimeIdx >= 0) {
                                    penalty = allCandidates[lastTimeIdx];
                                    lapValues = allCandidates.slice(0, lastTimeIdx);
                                } else {
                                    lapValues = allCandidates;
                                }
                            } else {
                                // 4 or fewer time values - all are laps, no penalty
                                lapValues = allCandidates;
                            }
                        }
                        
                        // Assign to LAP1-4 (pad with empty strings if needed)
                        const lap1 = lapValues[0] || '';
                        const lap2 = lapValues[1] || '';
                        const lap3 = lapValues[2] || '';
                        let lap4 = lapValues[3] || '';
                        
                        // Convert times for the result
                        const lap1Converted = convertTime(lap1 === '-' ? '' : lap1);
                        const lap2Converted = convertTime(lap2 === '-' ? '' : lap2);
                        const lap3Converted = convertTime(lap3 === '-' ? '' : lap3);
                        const lap4Converted = convertTime(lap4 === '-' ? '' : lap4);
                        const penaltyConverted = convertTime(penalty === '-' ? '' : penalty);
                        const totalTimeConverted = totalTime === 'DNF' ? 'DNF' : convertTime(totalTime);
                        
                        // Validation: sum of laps + penalty should equal total time
                        let validationError = '';
                        if (totalTimeConverted && totalTimeConverted !== 'DNF') {
                            const totalSecs = timeToSeconds(totalTimeConverted);
                            
                            // Sum all available lap times
                            let sumSecs = 0;
                            let hasAnyLap = false;
                            
                            [lap1Converted, lap2Converted, lap3Converted, lap4Converted].forEach(lap => {
                                const secs = timeToSeconds(lap);
                                if (secs !== null) {
                                    sumSecs += secs;
                                    hasAnyLap = true;
                                }
                            });
                            
                            // Add penalty if present
                            const penaltySecs = timeToSeconds(penaltyConverted);
                            if (penaltySecs !== null) {
                                sumSecs += penaltySecs;
                            }
                            
                            // Only validate if we have lap data and total time
                            if (hasAnyLap && totalSecs !== null) {
                                const diff = Math.abs(totalSecs - sumSecs);
                                const tolerance = 3; // seconds
                                
                                if (diff > tolerance) {
                                    validationError = `Time mismatch: laps+penalty=${Math.floor(sumSecs/60)}:${(sumSecs%60).toFixed(2)}, total=${Math.floor(totalSecs/60)}:${(totalSecs%60).toFixed(2)}, diff=${diff.toFixed(2)}s`;
                                    console.warn(`Validation error for ${name}: ${validationError}`);
                                }
                            }
                        }
                        
                        const result = {
                            Year: year,
                            Region: region,
                            'Race Name': raceName,
                            'Race Course': raceCourse,
                            'Race Category': currentCategory,
                            Placement: placement,
                            'Plate#': plateNum,
                            Name: name,
                            Team: team,
                            Points: points === '-' ? '' : points,
                            LAP1: lap1Converted,
                            LAP2: lap2Converted,
                            LAP3: lap3Converted,
                            LAP4: lap4Converted,
                            Penalty: penaltyConverted,
                            'Total Time': totalTimeConverted,
                            ValidationError: validationError
                        };
                        
                        results.push(result);
                        console.log(`Parsed: ${placement} ${plateNum} "${name}" "${team}" Points:${points || 'blank'}`);
                        
                        if (firstPageOnly && results.length >= 20) {
                            break;
                        }
                    }
                }
                
                console.log(`Total results parsed: ${results.length}`);
                return results;
            };

            const cleanTeamName = (team) => {
                if (!team || team === '-') return '';
                
                // Remove trailing dashes and spaces
                team = team.replace(/(\s+-)+\s*$/g, '');
                
                // Special handling for West High and East High - preserve "High" in name
                // Must come BEFORE general High School/HS removal
                if (/^West\s+High\s+School/i.test(team)) {
                    team = team.replace(/^West\s+High\s+School\s*/i, 'West High ');
                }
                if (/^East\s+High\s+School/i.test(team)) {
                    team = team.replace(/^East\s+High\s+School\s*/i, 'East High ');
                }
                if (/^East\s+HS$/i.test(team)) {
                    team = 'East High';
                }
                
                // Remove common suffixes
                // Mountain Bike Team variants MUST come first so "High School" can be removed after
                team = team.replace(/\s+Mountain\s+Biking\s+Team$/i, '');  // Layton variant
                team = team.replace(/\s+Mountain\s+Bike\s+Team$/i, '');
                team = team.replace(/\s+High\s+School$/i, '');
                team = team.replace(/\s+HS$/i, '');
                team = team.replace(/\s+Jr\s+Devo$/i, '');
                team = team.replace(/\s+Junior\s+Devo$/i, '');
                team = team.replace(/\s+DEVO$/i, '');  // Remove standalone DEVO after Jr Devo
                team = team.replace(/\s+MS$/i, '');  // Middle School
                team = team.replace(/\s+Composite$/i, '');
                team = team.replace(/\s+Comp$/i, '');
                
                // Remove mascot names
                team = team.replace(/\s+Red\s+Devils$/i, '');
                team = team.replace(/\s+Biking\s+Vikings$/i, '');  // Remove compound first
                team = team.replace(/\s+Vikings$/i, '');
                team = team.replace(/\s+Biking$/i, '');
                team = team.replace(/\s+Bobcats$/i, '');
                team = team.replace(/\s+Panthers$/i, '');
                team = team.replace(/\s+Flyers$/i, '');
                team = team.replace(/\s+Thunder$/i, '');
                team = team.replace(/\s+Bulldogs$/i, '');
                team = team.replace(/\s+Chaos$/i, '');
                
                return team.trim();
            };

            const downloadCSV = () => {
                const data = fullData || previewData;
                if (!data || data.length === 0) return;
                
                const headers = ['Year', 'Region', 'Race Name', 'Race Course', 'Race Category', 'Placement', 'Plate#', 'Name', 'Team', 'Points', 'LAP1', 'LAP2', 'LAP3', 'LAP4', 'Penalty', 'Total Time', 'ValidationError'];
                
                let csv = headers.join(',') + '\n';
                
                data.forEach(row => {
                    const values = headers.map(header => {
                        const value = row[header] || '';
                        // Escape commas and quotes
                        if (value.includes(',') || value.includes('"')) {
                            return `"${value.replace(/"/g, '""')}"`;
                        }
                        return value;
                    });
                    csv += values.join(',') + '\n';
                });
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fullData ? 'race_results_full.csv' : 'race_results_preview.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            };

            const dataToDisplay = fullData || previewData;

            return (
                <div className="container">
                    <div className="header">
                        <h1>üö¥ MTB Race Results Extractor</h1>
                        <p>Upload your PDF to extract and download race results as CSV</p>
                    </div>
                    
                    <div className="content">
                        <div 
                            className={`upload-section ${dragOver ? 'dragover' : ''}`}
                            onClick={() => fileInputRef.current.click()}
                            onDrop={handleDrop}
                            onDragOver={(e) => { e.preventDefault(); setDragOver(true); }}
                            onDragLeave={() => setDragOver(false)}
                        >
                            <div className="upload-icon">üìÑ</div>
                            <h3>{file ? file.name : 'Click or drag PDF file here'}</h3>
                            <p style={{ marginTop: '8px', color: '#6b7280' }}>
                                {file ? 'Click to select a different file' : 'MTB Race Results PDF'}
                            </p>
                            <input
                                ref={fileInputRef}
                                type="file"
                                accept=".pdf"
                                className="file-input"
                                onChange={(e) => handleFileSelect(e.target.files[0])}
                            />
                        </div>

                        {status && (
                            <div className={`status-message status-${status.type}`}>
                                <span>
                                    {status.type === 'info' && '‚ÑπÔ∏è'}
                                    {status.type === 'success' && '‚úÖ'}
                                    {status.type === 'error' && '‚ùå'}
                                </span>
                                <span>{status.message}</span>
                            </div>
                        )}

                        {loading && (
                            <div className="loading">
                                <div className="spinner"></div>
                                <span>Loading preview...</span>
                            </div>
                        )}

                        {dataToDisplay && dataToDisplay.length > 0 && (
                            <div className="preview-section">
                                <div className="preview-header">
                                    <h2>
                                        {fullData ? 'Full Results' : 'Preview (First Page Only)'}
                                        {!fullData && <span style={{ fontSize: '16px', fontWeight: 'normal', color: '#6b7280', marginLeft: '12px' }}>
                                            ‚Äî Process full document to see all results
                                        </span>}
                                    </h2>
                                </div>

                                <div className="stats">
                                    <div className="stat-card">
                                        <div className="stat-label">Total Entries</div>
                                        <div className="stat-value">{dataToDisplay.length}</div>
                                    </div>
                                    <div className="stat-card">
                                        <div className="stat-label">Categories</div>
                                        <div className="stat-value">
                                            {new Set(dataToDisplay.map(r => r['Race Category'])).size}
                                        </div>
                                    </div>
                                    <div className="stat-card">
                                        <div className="stat-label">Teams</div>
                                        <div className="stat-value">
                                            {new Set(dataToDisplay.map(r => r.Team).filter(t => t)).size}
                                        </div>
                                    </div>
                                    <div className="stat-card">
                                        <div className="stat-label">Race Course</div>
                                        <div className="stat-value">{dataToDisplay[0]?.['Race Course'] || 'N/A'}</div>
                                    </div>
                                    {dataToDisplay.filter(r => r.ValidationError).length > 0 && (
                                        <div className="stat-card" style={{ borderLeftColor: '#ef4444', background: '#fef2f2' }}>
                                            <div className="stat-label" style={{ color: '#991b1b' }}>‚ö†Ô∏è Validation Errors</div>
                                            <div className="stat-value" style={{ color: '#dc2626' }}>
                                                {dataToDisplay.filter(r => r.ValidationError).length}
                                            </div>
                                        </div>
                                    )}
                                </div>

                                <div className="action-buttons" style={{ marginBottom: '20px' }}>
                                    {!fullData && (
                                        <button 
                                            className="btn btn-primary"
                                            onClick={processFullDocument}
                                            disabled={processing}
                                        >
                                            {processing ? (
                                                <>
                                                    <div className="spinner-small"></div>
                                                    Processing...
                                                </>
                                            ) : (
                                                <>üìä Process Full Document</>
                                            )}
                                        </button>
                                    )}
                                    
                                    <button 
                                        className="btn btn-success"
                                        onClick={downloadCSV}
                                    >
                                        ‚¨áÔ∏è Download {fullData ? 'Full' : 'Preview'} CSV
                                    </button>
                                </div>

                                <div className="table-container">
                                    <table>
                                        <thead>
                                            <tr>
                                                <th>Placement</th>
                                                <th>Plate#</th>
                                                <th>Name</th>
                                                <th>Team</th>
                                                <th>Category</th>
                                                <th>Points</th>
                                                <th>LAP1</th>
                                                <th>LAP2</th>
                                                <th>LAP3</th>
                                                <th>LAP4</th>
                                                <th>Penalty</th>
                                                <th>Total Time</th>
                                                <th>Status</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {dataToDisplay.slice(0, 15).map((row, idx) => (
                                                <tr key={idx} style={row.ValidationError ? { background: '#fef2f2' } : {}}>
                                                    <td>{row.Placement}</td>
                                                    <td>{row['Plate#']}</td>
                                                    <td>{row.Name}</td>
                                                    <td>{row.Team}</td>
                                                    <td>{row['Race Category']}</td>
                                                    <td>{row.Points}</td>
                                                    <td>{row.LAP1}</td>
                                                    <td>{row.LAP2}</td>
                                                    <td>{row.LAP3}</td>
                                                    <td>{row.LAP4}</td>
                                                    <td>{row.Penalty}</td>
                                                    <td>{row['Total Time']}</td>
                                                    <td title={row.ValidationError || 'OK'}>
                                                        {row.ValidationError ? '‚ö†Ô∏è' : '‚úì'}
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>

                                {dataToDisplay.length > 15 && (
                                    <p style={{ textAlign: 'center', color: '#6b7280', marginBottom: '20px' }}>
                                        Showing first 15 of {dataToDisplay.length} entries
                                    </p>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<RaceResultsExtractor />, document.getElementById('root'));
    </script>
</body>
</html>
